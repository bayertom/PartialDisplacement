function [LN] = displaceByMinDist2AL(AL, LD, IDX, d_buff_outer, d_buff_inner, ten, smooth)
    %Initialize new polyline: a copy of the displaced one
    LN = LD;
    
    %Find point chains inside the buffer forming the displaced parts
    %Store their endpoints and endpoints of associated line segments
    inside = false; index = 1;
    [m, n] = size(IDX);
    S = [];
    NP = zeros(length(LD), 5);
    
    for i = 1 : m - 1
        %Get indices of points of the original line
        idx1 = IDX(i, 1); idx2 = IDX(i + 1, 1);
               
        %Process all points
        for j = idx1:idx2
            
            %Get distance of LN(i) to the nearest point of L, store values
            [jlmin, jmin, djmin, pjmin, cjmin] = findNearestPointAL(LD(j, :), AL);
            NP(j, :) = [jmin, jmin, djmin, pjmin];
            
%             [jmin, djmin, pjmin, cjmin] = findNearestPointsAL(LD(j, :), AL);
%             w = (1./djmin')';
%             ui = LD(IDX(i), :) - pjmin;
%             uin =  ui ./(sqrt(sum(ui'.^2,1)))';
%             ua = sum(w.* ui, 1)./sum(w,1);
%             pa = LD(IDX(i), :) - ua;
%             da = pdist([LD(IDX(i), :); pa],'euclidean');
%             NP(j, :) = [0, 0, da, pa];
            
            %Point inside the buffer
            if (djmin < d_buff_outer)
                %New start point
                if (inside == false)
                    S(index, 1) = j;
                    S(index, 3) = idx1;
                end
                
                %Point inside the buffer
                inside = true;
                
            %Point outside the buffer
            else
                %New end point
                if (inside == true)
                    S(index, 2) = j - 1;
                    S(index, 4) = idx2;
                    index = index + 1;
                end
                
                %Point outside the buffer
                inside = false;
            end
        end
    end
    
    %Last point is inside the buffer
    if (inside == true)
        S(index, 2) = j;
        S(index, 4) = IDX(m, 1);
    end
    
    %Create matrix of shifts
    dS = zeros(length(LD), 2);
    dSS = dS; dSP = dS; dSA = dS;
    K = ones(length(LD), 1);
    j = 1;
    
    %Process displaced parts one by one
    [m, n] = size(S);
    for i = 1: m
        idx1 = S(i, 1); idx2 = S(i, 2); %Interval of points inside the buffer
        idxs = S(i, 3); idxe = S(i, 4); %Start point of the first, end point of the last segment
        
        %Find start point of the segment in O (original line L)
        while ((IDX(j, 1) ~= idxs) && (j < length(IDX)))
            j = j + 1;
        end
        
        %Initialize shift behind the inner buffer
        dsmin = d_buff_outer;
        
        %Process all displaced points inside the outter buffer
        k = idx1;
        while k <= idx2
            %We found end point of the displaced segment, increment j
            %Skip last displaced point
            if ((k == IDX(j + 1, 1)) && (k ~= idxe))  
                j = j + 1;
                continue;
            end
            
            %Compute shifts to the outer buffer for a given point LD(k)
            [ds, dmink] = computeShiftMinDistAL(LD, NP, k, d_buff_outer);
            dS(k, :) = ds;
            
            %Compute the propagation coefficient k
            kp = propagationCoeff(k, idx1, idx2, ten);
            K(k) = kp;
                
            %Find the nearest point: nearest point generates the longest shift
            dsmin = min(dsmin, dmink);    
            
            %Increment index of the displaced point
            k = k + 1;
        end
        
       %Apply propagation
       dSP(idx1 : idx2, :) = K(idx1 : idx2) .* dS(idx1:idx2, :); 
       
       %Shift point to the inner buffer, use the longest shift generated by closest vertex
       fr = (d_buff_inner - dsmin)/(d_buff_outer - dsmin);
       dSS(idx1 : idx2, :) = fr * dSP(idx1: idx2, :);
              
    end
   
    %Smooth shifts sn for all segments: average of k-vectors sn
    dSA = smoothShifts(dSS, LD, smooth);
    
    %Remove directions intersecting each other
    [LD, dSA] = removeIntersectedDirections(LD, dSA);
    
    %New position of points
    LN = LD + dSA;
    
    %Apply LLR simplification
    LN = simplifyLLR(LN, 1.0001, 0.3);
    
    %for (i = 1 : length(LD))
    %    plot([LD(i, 1); LD(i, 1) + dSA(i, 1)], [LD(i, 2); LD(i, 2) + dSA(i, 2)], 'r');
    %end
   
end

